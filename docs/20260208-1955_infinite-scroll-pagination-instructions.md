# 리스트 12개 단위 무한 스크롤 로딩 작업 지시서

## 목표
각 페이지에서 리스트를 **전체 로딩하지 않고 12개씩** 무한 스크롤로 불러오도록 구조를 수정한다.

## 배경
현재 홈/스페이스 페이지에서 DB 쿼리로 모든 게시물을 불러온다. 이는 성능과 UX에 불리하며, 이미 API에는 커서 기반 페이지네이션이 존재한다.

## 요구 사항
1. 목록은 12개 단위로 로딩한다.
2. 스크롤 하단 도달 시 다음 페이지를 불러온다.
3. 중복/누락 없이 커서 기반으로 이어서 로딩한다.
4. 로딩 상태 및 더 이상 데이터 없음 상태 표시.

## 적용 범위
- 홈 페이지: `src/app/page.tsx`
- 스페이스 페이지: `src/app/space/[render_model]/page.tsx`
- 리스트 렌더링 컴포넌트 (필요 시 분리)
- API: `GET /api/posts?limit=12&cursor=...&space=...`

## 사전 확인
- `GET /api/posts`는 이미 `limit`/`cursor`/`space` 파라미터를 지원함.
- 커서 형식은 `base64(created_at|id)`로 구현되어 있음.

## 구현 방향

### 1) 서버 컴포넌트 → 클라이언트 컴포넌트 전환
- 무한 스크롤은 클라이언트에서 처리해야 한다.
- `page.tsx`에서 초기 데이터(첫 12개)만 서버에서 가져오고, 나머지는 클라이언트에서 로딩.

### 2) 데이터 로딩 흐름
1. 최초 12개 로딩 (SSR 또는 초기 fetch)
2. `nextCursor` 저장
3. 스크롤 바닥 감지 시 `/api/posts?limit=12&cursor=...` 호출
4. 결과를 기존 리스트에 append
5. `nextCursor`가 null이면 종료

### 3) 무한 스크롤 구현
- `IntersectionObserver` 사용
- 리스트 하단에 sentinel `<div ref>` 배치
- sentinel이 viewport에 진입하면 다음 페이지 fetch

### 4) 상태 관리
- `items`: 누적 리스트
- `nextCursor`: 다음 페이지 커서
- `loading`: 로딩 중 여부
- `hasMore`: 더 불러올 데이터 존재 여부

## 적용 페이지별 포인트

### 홈 (`/`)
- `GET /api/posts?limit=12`
- `nextCursor` 기준으로 이어서 요청

### 스페이스 (`/space/[render_model]`)
- `space` 파라미터를 포함하여 요청
- `/api/posts?limit=12&space=svg&cursor=...`

## 구현 단계
1. 홈/스페이스 리스트를 클라이언트 컴포넌트로 분리
2. 초기 로딩은 서버에서 12개만 전달
3. 무한 스크롤 로딩 로직 추가 (IntersectionObserver)
4. 로딩/종료 상태 UI 추가
5. 중복 로딩 방지 확인

## 완료 기준
- 각 리스트 페이지가 최초 12개만 로딩된다.
- 스크롤 시 다음 12개가 자동으로 로딩된다.
- 더 이상 데이터가 없으면 로딩이 멈추고 종료 상태가 표시된다.
